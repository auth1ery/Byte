{\r\n  \"version\": \"1.0.0\",\r\n  \"script\": \"<script>\/\/ ===============================\r\n\/\/ Runtime trackers & helpers\r\n\/\/ ===============================\r\nconst __byte_runtime = { buttons: [], keyHandlers: [] };\r\n\r\n\/\/ ===============================\r\n\/\/ Byte keywords for highlighting\r\n\/\/ ===============================\r\nconst BYTE_KEYWORDS = [\r\n  \"STR\",\"EXE\",\"RED\",\"DLE\",\"VAR\",\"STO\",\"THN\",\"WIT\",\"LIN\",\"RRI\",\r\n  \"onStr\",\"func\",\"const\",\"AND\",\"NOT\",\"IF\",\r\n  \"Change\",\"SIPHON\",\"Share\",\"addNum\",\"dleNum\",\"Do\",\"-c\",\r\n  \"Button\",\"Check\",\"Spawn.New\",\"raycast\",\"Hit\",\"Keybind\",\"velocity\",\"require\",\r\n  \"ST\",\"AT\",\"TA\",\"BT\",\"TS\"\r\n].map(k => k.replace(\/[.*+?^${}()|[\\]\\\\]\/g, '\\\\$&')); \/\/ escape for regex\r\n\r\nCodeMirror.defineMode(\"byte\", function(config){\r\n  const keywordRegex = new RegExp(\"\\\\b(\" + BYTE_KEYWORDS.join(\"|\") + \")\\\\b\");\r\n  return {\r\n    token: function(stream) {\r\n      if (stream.match(\/^\\\/\\\/.*\/)) return \"comment\";\r\n      if (stream.match(\/^=\\\/\\\/.*\/)) return \"comment\";\r\n      if (stream.match(\/^\".*?\"\/)) return \"string\";\r\n      if (stream.match(keywordRegex)) return \"keyword\";\r\n      stream.next();\r\n      return null;\r\n    }\r\n  };\r\n});\r\n\r\nconst editor = CodeMirror.fromTextArea(document.getElementById(\"editor\"), {\r\n  mode: \"byte\", theme: \"dracula\", lineNumbers: true, indentUnit: 2\r\n});\r\n\r\nlet errorLineHandle = null;\r\nlet currentLineHandle = null;\r\nfunction highlightError(lineNum){\r\n  if (errorLineHandle) editor.removeLineClass(errorLineHandle, \"background\", \"line-error\");\r\n  errorLineHandle = editor.addLineClass(lineNum, \"background\", \"line-error\");\r\n}\r\nfunction highlightCurrentLine(lineNum){\r\n  if (currentLineHandle) editor.removeLineClass(currentLineHandle, \"background\", \"line-current\");\r\n  currentLineHandle = editor.addLineClass(lineNum, \"background\", \"line-current\");\r\n}\r\n\r\n\/\/ ===============================\r\n\/\/ Cleanup runtime (buttons & key handlers)\r\n\/\/ ===============================\r\nfunction cleanupRuntime(){\r\n  \/\/ remove buttons created by previous runs\r\n  (__byte_runtime.buttons || []).forEach(b=>{\r\n    try{ b.remove(); }catch(e){}\r\n  });\r\n  __byte_runtime.buttons.length = 0;\r\n\r\n  \/\/ remove key handlers\r\n  (__byte_runtime.keyHandlers || []).forEach(k=>{\r\n    try{ window.removeEventListener(\"keydown\", k.handler); }catch(e){}\r\n  });\r\n  __byte_runtime.keyHandlers.length = 0;\r\n\r\n  \/\/ Also remove any orphan DOM buttons with class 'byte-btn' just in case\r\n  document.body.querySelectorAll(\"button.byte-btn\").forEach(b=>b.remove());\r\n}\r\n\r\n\/\/ ===============================\r\n\/\/ Byte Interpreter Core\r\n\/\/ ===============================\r\nasync function runByteAsync(code){\r\n  const output = [];\r\n  const globalVars = {};           \/\/ declared with VAR or const at top-level\r\n  const functions = {};            \/\/ parsed functions\r\n  const declaredVarOrder = [];     \/\/ for addNum\/dleNum fallback\r\n  const buttons = {};\r\n  let stopped = false;\r\n  const wait = ms => new Promise(res => setTimeout(res, ms));\r\n  const queue = code.split(\"\\n\").map((l,i)=>({ raw: l, line: l.trim(), number: i }));\r\n\r\n  \/\/ Basic sanity\r\n  if (queue.length === 0 || queue[0].line !== \"STR\"){\r\n    document.getElementById(\"output\").textContent = \"Error: STR missing at start of script.\";\r\n    return;\r\n  }\r\n\r\n  \/\/ ===============================\r\n  \/\/ Pre-parse block checker (detect unmatched\/unfinished blocks)\r\n  \/\/ ===============================\r\n  function precheckBlocks(q){\r\n    const stack = [];\r\n    const errors = [];\r\n    for (let i=0;i<q.length;i++){\r\n      const ln = q[i].line;\r\n      \/\/ ignore blank lines\/comments\r\n      if (!ln || ln.startsWith(\"\/\/\") || ln.startsWith(\"=\/\/\")) continue;\r\n\r\n      \/\/ function header: func Name =  OR Name =\r\n      if (\/^func\\s+[A-Za-z_]\\w*\\s*=$\/i.test(ln) || \/^[A-Za-z_]\\w*\\s*=$\/.test(ln)){\r\n        \/\/ avoid counting assignment lines that are part of code (we only treat lines with only \"name =\" as function header)\r\n        stack.push({type:'func', line:i});\r\n        continue;\r\n      }\r\n      \/\/ loop header: -c + N =\r\n      if (\/^-c\\s*\\+\\s*\\d+\\s*=$\/.test(ln)){\r\n        stack.push({type:'loop', line:i});\r\n        continue;\r\n      }\r\n      \/\/ loop close '-'\r\n      if (ln === \"-\"){\r\n        const top = stack.pop();\r\n        if (!top || top.type !== 'loop'){\r\n          errors.push({msg: 'Unmatched loop close \"-\"', line:i});\r\n        }\r\n        continue;\r\n      }\r\n      \/\/ end for functions\/conditionals\r\n      if (\/^end$\/i.test(ln) || \/^END$\/.test(ln) || \/^END$\/.test(ln)){\r\n        const top = stack.pop();\r\n        if (!top || top.type !== 'func'){\r\n          errors.push({msg: 'Unmatched END \/ end', line:i});\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n    \/\/ any remaining unmatched blocks\r\n    while (stack.length){\r\n      const t = stack.pop();\r\n      errors.push({msg: 'Unclosed block: ' + t.type, line: t.line});\r\n    }\r\n    return errors;\r\n  }\r\n\r\n  const preErrors = precheckBlocks(queue);\r\n  if (preErrors.length){\r\n    \/\/ highlight first error, show messages\r\n    const first = preErrors[0];\r\n    highlightError(first.line);\r\n    const messages = preErrors.map(e=>`Line ${e.line+1}: ${e.msg}`).join(\"\\n\");\r\n    document.getElementById(\"output\").textContent = \"Parse Errors:\\n\" + messages;\r\n    return;\r\n  }\r\n\r\n  \/\/ Helper: safe expression evaluator (supports = for equality, AND, NOT, numeric ops, comparison)\r\n  function transformExprToJS(expr){\r\n    \/\/ Replace Byte tokens with JS equivalents\r\n    \/\/ 'AND' -> '&&', 'NOT' -> '!'\r\n    let e = expr.replace(\/\\bAND\\b\/g, \"&&\").replace(\/\\bNOT\\b\/g, \"!\");\r\n    \/\/ Replace single '=' for comparisons (avoid => and >= <= !=)\r\n    e = e.replace(\/([^!<>=])\\s*=\\s*([^=])\/g, (m, a, b) => `${a}==${b}`);\r\n    return e;\r\n  }\r\n\r\n  function isNumericString(s){\r\n    return \/^-?\\d+(\\.\\d+)?$\/.test(s);\r\n  }\r\n\r\n  function lookupVar(name, locals){\r\n    if (locals && locals.hasOwnProperty(name)) return locals[name];\r\n    if (globalVars.hasOwnProperty(name)) return globalVars[name];\r\n    \/\/ Unset variables default to 0 per many examples\r\n    return 0;\r\n  }\r\n\r\n  function safeEval(expr, locals){\r\n    const transformed = transformExprToJS(expr);\r\n    \/\/ Allow only characters that are safe for our small expression language\r\n    if (!\/^[\\w\\s\\+\\-\\*\\\/\\.\\(\\)\\<\\>\\!\\=\\&\\|\\?\"',:]+$\/.test(transformed)){\r\n      throw new Error(\"Unsafe characters in expression: \" + expr);\r\n    }\r\n    \/\/ Replace variable names by references into a local object '__V'\r\n    const replaced = transformed.replace(\/\\b([A-Za-z_]\\w*)\\b\/g, (m)=>{\r\n      if (m === \"true\" || m === \"false\") return m;\r\n      if (\/^\\d+(\\.\\d+)?$\/.test(m)) return m;\r\n      return `__V[\"${m}\"]`;\r\n    });\r\n    const __V = Object.assign({}, globalVars, locals || {});\r\n    \/\/ eslint-disable-next-line no-new-func\r\n    const fn = new Function(\"__V\", \"return (\" + replaced + \");\");\r\n    return fn(__V);\r\n  }\r\n\r\n  \/\/ Parse functions and multi-line blocks\r\n  for (let i = 0; i < queue.length; i++){\r\n    const line = queue[i].line;\r\n    let m = line.match(\/^func\\s+([A-Za-z_]\\w*)\\s*=$\/i);\r\n    if (!m){\r\n      m = line.match(\/^([A-Za-z_]\\w*)\\s*=$\/);\r\n    }\r\n    if (m){\r\n      const name = m[1];\r\n      const body = [];\r\n      let j = i + 1;\r\n      while (j < queue.length && !\/^end$\/i.test(queue[j].line) && queue[j].line !== \"END\"){\r\n        body.push(queue[j]);\r\n        j++;\r\n      }\r\n      functions[name] = body;\r\n      i = j; \/\/ skip to end\r\n    }\r\n  }\r\n\r\n  \/\/ Helper: parse concatenation expression inside RRI parentheses\r\n  function parseConcatExpression(expr, locals){\r\n    const parts = [];\r\n    let cur = \"\";\r\n    let inQuotes = false;\r\n    for (let i=0;i<expr.length;i++){\r\n      const c = expr[i];\r\n      if (c === '\"') {\r\n        cur += c;\r\n        inQuotes = !inQuotes;\r\n        continue;\r\n      }\r\n      if (!inQuotes && c === '+'){\r\n        parts.push(cur.trim());\r\n        cur = \"\";\r\n      } else {\r\n        cur += c;\r\n      }\r\n    }\r\n    if (cur.trim() !== \"\") parts.push(cur.trim());\r\n    const evaluated = parts.map(p=>{\r\n      if (\/^\".*\"$\/.test(p)) return p.slice(1,-1);\r\n      if (isNumericString(p)) return Number(p);\r\n      try {\r\n        if (\/^[A-Za-z_]\\w*$\/.test(p)){\r\n          const v = lookupVar(p, locals);\r\n          return v;\r\n        }\r\n        const val = safeEval(p, locals);\r\n        return val;\r\n      } catch (err){\r\n        return p;\r\n      }\r\n    });\r\n    return evaluated.join(\"\");\r\n  }\r\n\r\n  \/\/ Execution context stack (for local scoping)\r\n  const callStack = [];\r\n\r\n  async function executeFunction(fnName){\r\n    if (!functions[fnName]) throw new Error(\"Function not found: \" + fnName);\r\n    callStack.push(fnName);\r\n    const locals = {};\r\n    for (let i=0;i<functions[fnName].length;i++){\r\n      await executeLine(functions[fnName][i], locals);\r\n      if (stopped) break;\r\n    }\r\n    callStack.pop();\r\n  }\r\n\r\n  \/\/ Utility: collect block lines for \"-c + N =\" loop (multi-line until single line '-')\r\n  function collectBlock(startIndex){\r\n    const block = [];\r\n    let j = startIndex + 1;\r\n    while (j < queue.length && queue[j].line !== \"-\"){\r\n      block.push(queue[j]);\r\n      j++;\r\n    }\r\n    return { block, endIndex: j };\r\n  }\r\n\r\n  \/\/ addNum\/dleNum behavior: operate on most recently declared VAR or named variable if provided\r\n  function operateAddDle(op, amount, locals){\r\n    let target = declaredVarOrder.length ? declaredVarOrder[declaredVarOrder.length - 1] : null;\r\n    if (!target){\r\n      const keys = Object.keys(globalVars);\r\n      target = keys.length ? keys[0] : null;\r\n    }\r\n    if (!target) throw new Error(op + \" has no target variable to operate on.\");\r\n    const curr = lookupVar(target, locals);\r\n    const newVal = (Number(curr) || 0) + (op === \"add\" ? Number(amount) : -Number(amount));\r\n    if (locals && !globalVars.hasOwnProperty(target)){\r\n      locals[target] = newVal;\r\n    } else {\r\n      globalVars[target] = newVal;\r\n    }\r\n  }\r\n\r\n  \/\/ Line execution\r\n  async function executeLine(lineObj, locals = {}){\r\n    const { line, number } = lineObj;\r\n    highlightCurrentLine(number);\r\n\r\n    try{\r\n      if (!line || line.startsWith(\"\/\/\") || line.startsWith(\"=\/\/\") || line === \"STR\") return;\r\n      let m;\r\n      if (m = line.match(\/^VAR\\s*\\[\\s*([A-Za-z_]\\w*)\\s*\\](?:\\s+([A-Za-z_]\\w*))?$\/)){\r\n        const name = m[1];\r\n        globalVars[name] = 0;\r\n        declaredVarOrder.push(name);\r\n        return;\r\n      }\r\n\r\n      if (m = line.match(\/^const\\s+([A-Za-z_]\\w*)\\s*=\\s*(.+)$\/)){\r\n        const name = m[1];\r\n        const expr = m[2].trim();\r\n        const val = safeEval(expr, locals);\r\n        globalVars[name] = val;\r\n        return;\r\n      }\r\n\r\n      if (m = line.match(\/^([A-Za-z_]\\w*)\\s*=\\s*\"([^\"]+)\"\\s*EXE\\s*\\[([A-Za-z_]\\w*)\\]\\s*$\/)){\r\n        const varName = m[1];\r\n        const key = m[2];\r\n        const fn = m[3];\r\n        globalVars[varName] = key;\r\n        const keyHandler = function(e){\r\n          if (e.key.toUpperCase() === key.toUpperCase()){\r\n            if (functions[fn]) executeFunction(fn).catch(()=>{});\r\n          }\r\n        };\r\n        window.addEventListener(\"keydown\", keyHandler);\r\n        __byte_runtime.keyHandlers.push({ key, handler: keyHandler });\r\n        return;\r\n      }\r\n\r\n      if (m = line.match(\/^([A-Za-z_]\\w*)\\s*=\\s*(.+)$\/)){\r\n        const name = m[1];\r\n        const expr = m[2].trim();\r\n        const val = ( \/^\".*\"$\/.test(expr) )\r\n          ? expr.slice(1,-1)\r\n          : safeEval(expr, locals);\r\n        if (globalVars.hasOwnProperty(name)){\r\n          globalVars[name] = val;\r\n        } else if (callStack.length > 0){\r\n          locals[name] = val;\r\n        } else {\r\n          globalVars[name] = val;\r\n        }\r\n        if (!declaredVarOrder.includes(name)) declaredVarOrder.push(name);\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"RRI\")){\r\n        m = line.match(\/^RRI\\s*\\(\\s*([\\s\\S]*?)\\s*\\)\\s*-\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid RRI syntax\");\r\n        const inner = m[1];\r\n        const text = parseConcatExpression(inner, locals);\r\n        output.push(String(text));\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"WIT\")){\r\n        m = line.match(\/^WIT\\s*=\\s*([\\d.]+)\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid WIT syntax\");\r\n        await wait(Number(m[1]) * 1000);\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"EXE\")){\r\n        m = line.match(\/^EXE\\s*\\[\\s*([A-Za-z_]\\w*)\\s*\\]\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid EXE syntax\");\r\n        const fnName = m[1];\r\n        await executeFunction(fnName);\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"Button\")){\r\n        m = line.match(\/^Button\\s*\\+\\s*\"([^\"]+)\"(?:\\s+EXE\\s*\\[\\s*([A-Za-z_]\\w*)\\s*\\])?\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid Button syntax\");\r\n        const label = m[1];\r\n        const fn = m[2];\r\n        const btn = document.createElement(\"button\");\r\n        btn.textContent = label;\r\n        btn.classList.add(\"byte-btn\");\r\n        document.body.appendChild(btn);\r\n        buttons[label] = btn;\r\n        __byte_runtime.buttons.push(btn);\r\n        if (fn){\r\n          const listener = async ()=>{ await executeFunction(fn).catch(()=>{}); };\r\n          btn.addEventListener(\"click\", listener);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"-c\")){\r\n        m = line.match(\/^-c\\s*\\+\\s*(\\d+)\\s*=\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid loop syntax\");\r\n        const count = Number(m[1]);\r\n        const { block, endIndex } = collectBlock(number);\r\n        if (!block.length) return;\r\n        for (let iter=0; iter<count; iter++){\r\n          for (let b=0; b<block.length; b++){\r\n            await executeLine(block[b], locals);\r\n            if (stopped) break;\r\n          }\r\n          if (stopped) break;\r\n        }\r\n        return;\r\n      }\r\n\r\n      m = line.match(\/^-c\\s*\\+\\s*(\\d+)\\s*=\\s*(.+)-\\s*$\/);\r\n      if (m){\r\n        const count = Number(m[1]);\r\n        const cmd = m[2].trim();\r\n        for (let i=0;i<count;i++){\r\n          await executeLine({line: cmd, number}, locals);\r\n          if (stopped) break;\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"LIN\")){\r\n        m = line.match(\/^LIN\\s+(.+)$\/);\r\n        if (!m) throw new Error(\"Invalid LIN syntax\");\r\n        globalVars[\"__LIN\"] = m[1].trim();\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"Change\")){\r\n        m = line.match(\/^Change\\s+([A-Za-z_]\\w*)\\s*=\\s*(.+)$\/);\r\n        if (!m) throw new Error(\"Invalid Change syntax\");\r\n        const varName = m[1];\r\n        const expr = m[2].trim();\r\n        const val = safeEval(expr, locals);\r\n        if (globalVars.hasOwnProperty(varName)) globalVars[varName] = val;\r\n        else if (callStack.length > 0) locals[varName] = val;\r\n        else globalVars[varName] = val;\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"SIPHON\")){\r\n        m = line.match(\/^SIPHON\\s*(?:\\+\\s*([\\d.]+))?\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid SIPHON syntax\");\r\n        const secs = Number(m[1] || 0);\r\n        if (secs > 0) await wait(secs*1000);\r\n        const lastVar = declaredVarOrder.length ? declaredVarOrder[declaredVarOrder.length-1] : null;\r\n        if (lastVar) {\r\n          globalVars[`${lastVar}_siphoned`] = true;\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"Share\")){\r\n        m = line.match(\/^Share\\s*\\[\\s*([A-Za-z_]\\w*)\\s*\\]\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid Share syntax\");\r\n        const varName = m[1];\r\n        globalVars[varName + \"_shared\"] = lookupVar(varName, locals);\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"addNum\")){\r\n        m = line.match(\/^addNum\\s*\\+\\s*([\\d.]+)\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid addNum syntax\");\r\n        operateAddDle(\"add\", Number(m[1]), locals);\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"dleNum\")){\r\n        m = line.match(\/^dleNum\\s*\\+\\s*([\\d.]+)\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid dleNum syntax\");\r\n        operateAddDle(\"dle\", Number(m[1]), locals);\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"do\") || line.startsWith(\"Do\")){\r\n        m = line.match(\/^(?:do|Do)\\s+([A-Za-z_]\\w*)\\s*$\/);\r\n        if (!m) throw new Error(\"Invalid do syntax\");\r\n        const name = m[1];\r\n        if (functions[name]) {\r\n          await executeFunction(name);\r\n          return;\r\n        }\r\n        const possible = lookupVar(name, locals);\r\n        if (typeof possible === \"string\" && functions[possible]) {\r\n          await executeFunction(possible);\r\n          return;\r\n        }\r\n        throw new Error(\"do target not found: \" + name);\r\n      }\r\n\r\n      if (line.startsWith(\"IF\")){\r\n        m = line.match(\/^IF\\s+(.+)\\s+THN\\s*$\/);\r\n        if (m){\r\n          const expr = m[1].trim();\r\n          const block = [];\r\n          let j = number + 1;\r\n          while (j < queue.length && !\/^(END|end)$\/.test(queue[j].line)){\r\n            block.push(queue[j]);\r\n            j++;\r\n          }\r\n          const cond = safeEval(expr, locals);\r\n          if (cond){\r\n            for (let b=0; b<block.length; b++){\r\n              await executeLine(block[b], locals);\r\n              if (stopped) break;\r\n            }\r\n          }\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (line === \"STO\"){\r\n        stopped = true;\r\n        return;\r\n      }\r\n\r\n      if (line.startsWith(\"raycast\") || line.startsWith(\"Hit\") || line.startsWith(\"velocity\")){\r\n        m = line.match(\/^([A-Za-z_]\\w*)\\s*=\\s*(.+)$\/);\r\n        if (m){\r\n          const name = m[1];\r\n          const expr = m[2].trim();\r\n          const val = \/^\".*\"$\/.test(expr) ? expr.slice(1,-1) : safeEval(expr, locals);\r\n          if (globalVars.hasOwnProperty(name)) globalVars[name] = val;\r\n          else if (callStack.length > 0) locals[name] = val;\r\n          else globalVars[name] = val;\r\n          return;\r\n        }\r\n      }\r\n\r\n      throw new Error(\"Unknown command: \" + line);\r\n    }catch(err){\r\n      highlightError(number);\r\n      output.push(`Error on line ${number+1}: ${err.message}`);\r\n      if (callStack.length > 0) output.push(\"Stack trace:\\n\" + callStack.join(\" -> \"));\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  \/\/ run onStr automatically if present (docs: onStr runs at script start)\r\n  if (functions[\"onStr\"]) {\r\n    try {\r\n      await executeFunction(\"onStr\");\r\n    } catch(e){\r\n      \/\/ stop if onStr errors\r\n    }\r\n  }\r\n\r\n  \/\/ Execute top-level lines (after parsing functions)\r\n  try{\r\n    for (let i=0;i<queue.length;i++){\r\n      await executeLine(queue[i], {});\r\n      if (stopped) break;\r\n    }\r\n  }catch(e){\r\n    \/\/ stop on error (already reported)\r\n  } finally {\r\n    if (currentLineHandle){\r\n      editor.removeLineClass(currentLineHandle, \"background\", \"line-current\");\r\n      currentLineHandle = null;\r\n    }\r\n  }\r\n\r\n  document.getElementById(\"output\").textContent = output.join(\"\\n\");\r\n}\r\n\r\n\/\/ =========================\r\n\/\/ Buttons (Run \/ Clear \/ Docs) with cleanup\r\n\/\/ =========================\r\ndocument.getElementById(\"run\").addEventListener(\"click\", async ()=>{\r\n  \/\/ cleanup any previous runtime artifacts & highlights\r\n  cleanupRuntime();\r\n  document.getElementById(\"output\").textContent = \"\";\r\n  if (errorLineHandle){ editor.removeLineClass(errorLineHandle,\"background\",\"line-error\"); errorLineHandle = null; }\r\n  if (currentLineHandle){ editor.removeLineClass(currentLineHandle,\"background\",\"line-current\"); currentLineHandle = null; }\r\n\r\n  await runByteAsync(editor.getValue());\r\n});\r\ndocument.getElementById(\"clear\").addEventListener(\"click\", ()=>{\r\n  cleanupRuntime();\r\n  document.getElementById(\"output\").textContent = \"\";\r\n  if (errorLineHandle){ editor.removeLineClass(errorLineHandle,\"background\",\"line-error\"); errorLineHandle = null; }\r\n  if (currentLineHandle){ editor.removeLineClass(currentLineHandle,\"background\",\"line-current\"); currentLineHandle = null; }\r\n});\r\ndocument.getElementById(\"docs\").addEventListener(\"click\", ()=>{\r\n  window.open(\"https:\/\/bytedev.neocities.org\/docs.html\", \"_blank\");\r\n});<\/script>\"\r\n}\r\n
